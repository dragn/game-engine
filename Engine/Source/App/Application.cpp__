#include <vector>
#include <glm/gtx/transform.hpp>

namespace vh {

const Uint32 FPS_LIMIT = 60;

void Application::Run() {
    try {
        // Main loop
        while (true) {
            switch(mState) {
                case eApplicationState_Init:
                    DoInit();
                    break;
                case eApplicationState_Running:
                    DoRun();
                    break;
                case eApplicationState_Close:
                    DoClose();
                    break;
                case eApplicationState_Closed:
                    SDL_GL_DeleteContext(mGLContext);
                    SDL_DestroyWindow(mWindow);
                    SDL_Quit();
                    LOG(INFO) << "Application closed";
                    return;
            }
        }
    } catch (...) {
        auto eptr = std::current_exception;
        if (eptr) LOG(ERROR) << "Exception occured";
    }
}

void Application::DoInit() {
    LOG(INFO) << "Starting application";

    LOG(INFO) << "SDL Initialization";
    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
        LOG(FATAL) << SDL_GetError();
        mState = eApplicationState_Closed;
        return;
    }

    // Window mode MUST include SDL_WINDOW_OPENGL for use with OpenGL.
    mWindow = SDL_CreateWindow(
            "GameEngine Demo", 0, 0,
            SCREEN_WIDTH, SCREEN_HEIGHT,
            SDL_WINDOW_OPENGL|SDL_WINDOW_RESIZABLE);

    mWindowID = SDL_GetWindowID(mWindow);

    // Set relative mouse mode
    SDL_SetRelativeMouseMode(SDL_TRUE);

    // Create an OpenGL context associated with the mWindow.
    mGLContext = SDL_GL_CreateContext(mWindow);

    vh::RendererOptions opts;
    mRenderer = new SDLRenderer(mWindow, opts);
    mRenderer->Init();

    LOG(INFO) << "Application init complete, switch to running";
    mState = eApplicationState_Running;
}

void Application::DoRun() {
    HandleEvents();

    CHECK(mRenderer);

    if (mLevelMesh == nullptr && mRenderer->GetState() == vh::eRendererState_Ready) {
        // -- TODO: temporary. should be done with events.
        mLevelMesh = new vh::Mesh();

        vh::Utils::importWavefront(mLevelMesh, "Models/shadow_scene/shadow_scene.obj");
        mRenderer->AddObject(mLevelMesh);

        std::vector<vh::LightSource> lights;
        lights.push_back({ V3(0, 2, 4), 0.5 });
        lights.push_back({ V3(0, 3, -2), 0.3 });
        lights.push_back({ V3(0, 1, -5), 0.3 });
        mRenderer->SetLightSources(lights);
        // --
    }

    static Uint32 last = SDL_GetTicks();
    static Uint32 next;
    static Uint32 lastRender = last;
    static Uint32 lastFPSprint = last;
    static Uint32 frames = 0;
    static Uint32 spf = 1000 / FPS_LIMIT;

    next = SDL_GetTicks();
    if (next != last) {
        mWorld.Tick(next - last);
        mRenderer->Tick();
        last = next;
    }
    if (next - lastRender > spf) {
        if (mRenderer->GetState() == vh::eRendererState_Ready) {
            M4 view = glm::lookAt(mWorld.camera().pos(),
                    mWorld.camera().pos() + mWorld.camera().forward(), mWorld.camera().up());
            mRenderer->SetView(view);
            mRenderer->Render();
        }
        lastRender = next;
        frames++;
        if (lastRender - lastFPSprint > 1000) {
            LOG(INFO) << (lastRender - lastFPSprint) / frames << " ms/frame";
            lastFPSprint = lastRender;
            frames = 0;
        }
    }
}

void Application::DoClose() {
    if (mRenderer != nullptr) {
        if (mLevelMesh != nullptr) {
            mRenderer->RemoveObject(mLevelMesh);
            mLevelMesh = nullptr;
        }
        if (mRenderer->GetState() == vh::eRendererState_Closed) {
            delete mRenderer;
            mRenderer = nullptr;
            mState = eApplicationState_Closed;
        } else if (mRenderer->GetState() != vh::eRendererState_Close) {
            LOG(INFO) << "Requesting renderer to shutdown";
            mRenderer->Close();
            mRenderer->Tick();
        }
    } else {
        mState = eApplicationState_Closed;
    }
}

void Application::HandleEvents() {
    SDL_Event event;
    while (SDL_PollEvent(&event)) {
        if (event.window.windowID == mWindowID) {
            HandleEvent(&event);
        }
    }
}

void Application::HandleEvent(SDL_Event *event) {
    mWorld.HandleEvent(event);
    switch (event->type) {
        case SDL_WINDOWEVENT:
            switch (event->window.event) {
                case SDL_WINDOWEVENT_CLOSE:
                    event->type = SDL_QUIT;
                    SDL_PushEvent(event);
                    break;
            }
            break;
        case SDL_QUIT:
            mState = eApplicationState_Close;
            break;
    }
}

}
