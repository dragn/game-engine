#pragma once
#include<map>
#include<string>
namespace GameEngine {
  const std::map<std::string, std::string> Shaders = {{"SkyDome_VS.glsl","\nlayout(location = 0) in vec3 vertexPos;\n\nout vec3 texCoord;\n\nuniform mat4 MVP;\n\nvoid main() {\n gl_Position = MVP * vec4(vertexPos, 1.0);\n texCoord = vertexPos;\n}\n"},{"SimpleShader_VS.glsl","\nlayout(location = 0) in vec3 vertexPos_modelspace;\nlayout(location = 1) in vec3 vertexNormal_modelspace;\n\nlayout(location = 2) in vec3 vertexAColor;\nlayout(location = 3) in vec3 vertexDColor;\nlayout(location = 4) in vec3 vertexSColor;\n\nout vec3 fragmentAColor;\nout vec3 fragmentDColor;\nout vec3 fragmentSColor;\n\nout vec3 Normal_cameraspace;\nout vec3 LightDirection_cameraspace;\nout vec3 EyeDirection_cameraspace;\nout float LightDistance;\n\nuniform mat4 MVP;\nuniform mat4 M;\nuniform mat4 V;\nuniform vec3 LightPosition_worldspace;\n\nvoid main() {\n gl_Position = MVP * vec4(vertexPos_modelspace, 1);\n\n vec3 Position_worldspace = (M * vec4(vertexPos_modelspace, 1)).xyz;\n\n LightDistance = distance(Position_worldspace, LightPosition_worldspace);\n\n vec3 vertexPos_cameraspace = (V * M * vec4(vertexPos_modelspace, 1)).xyz;\n EyeDirection_cameraspace = vec3(0) - vertexPos_cameraspace;\n\n vec3 LightPosition_cameraspace = (V * vec4(LightPosition_worldspace, 1)).xyz;\n LightDirection_cameraspace = LightPosition_cameraspace + EyeDirection_cameraspace;\n\n Normal_cameraspace = (V * M * vec4(vertexNormal_modelspace, 0)).xyz;\n\n fragmentAColor = vertexAColor;\n fragmentDColor = vertexDColor;\n fragmentSColor = vertexSColor;\n}\n"},{"SkyDome_FS.glsl","\nin lowp vec3 texCoord;\n\nout lowp vec3 color;\n\nuniform samplerCube skySampler;\n\nvoid main() {\n color = texture(skySampler, texCoord).rgb;\n}\n"},{"SimpleShader_FS.glsl","\nin lowp vec2 UV;\n\nin lowp vec3 fragmentAColor;\nin lowp vec3 fragmentDColor;\nin lowp vec3 fragmentSColor;\n\nin lowp vec3 Normal_cameraspace;\nin lowp vec3 LightDirection_cameraspace;\nin lowp vec3 EyeDirection_cameraspace;\nin lowp float LightDistance;\n\nout lowp vec3 color;\n\nuniform sampler2D textureSampler;\n\nvoid main() {\n lowp vec3 n = normalize(Normal_cameraspace);\n lowp vec3 l = normalize(LightDirection_cameraspace);\n\n lowp vec3 E = normalize(EyeDirection_cameraspace);\n lowp vec3 R = reflect(- l, n);\n lowp float cosAlpha = clamp(dot(E, R), 0, 1); \n\n lowp float cosTheta = clamp(dot(n, l), 0, 1);\n lowp float LightPower = 1f;\n\n lowp vec3 temp;\n\n if (LightDistance > 0f) {\n color = fragmentAColor * 0.1 +\n fragmentDColor * cosTheta * LightPower +\n fragmentSColor * pow(cosAlpha, 5) * LightPower;\n }\n}\n"},};
}